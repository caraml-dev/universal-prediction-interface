syntax = "proto3";

package caraml.upi.v1;

import "caraml/upi/v1/variable.proto";
import "caraml/upi/v1/table.proto";
import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";

// Service for performing model prediction
service UniversalPredictionService {
  rpc PredictValues(PredictValuesRequest)
    returns (PredictValuesResponse) {
     option (google.api.http) = {
                post : "/v1/predict"
                body : "*"
    };
  }
}

// Represents a request to predict multiple values
message PredictValuesRequest {
  // Prediction table contains instances to be predicted.
  // Each row in the table correspond to one prediction instance.
  // Prediction table should contain all preprocessed feature that model use to perform prediction.
  // The column ordering in the prediction table must be the same as feature order expected by model in the case of standard model.
  // Prediction table can be populated via 3 ways:
  // - By performing preprocessing in the client-side and sent as part of original request.
  // - By transforming feature values stored in transformer_inputs.
  // - By retrieving precomputed feature value from feature store. 
  // Row ID of the prediction_table must be populated by the client and can be used
  // to join a row in prediction_table with another row in the prediction_result_table,
  // and to track predictions generated by multiple models.
  // The user is expected to include row ID (along with prediction ID)
  // when calling the observations API so that predictions
  // and observations can be joined. 
  // NOTE: the ordering of rows might differ in the response but the number of row must remain the same.
  Table prediction_table = 1;

  // Transformer input contains list of tables and variables that can be used to enrich prediction_table using transformer.
  // Typically transformer_inputs contains:
  // - unprocessed/raw features that requires further transformation. 
  // - list of entities for which their precomputed features are retrieved from feature store using standard transformer.
  TransformerInput transformer_input = 4;

  // Name of the concept we wish to predict.
  // For example in context of iris classification problem it can be "iris-species"
  string target_name = 2;

  // Prediction context may contain additional data applicable to all prediction instances
  // For example it can be used to store information for traffic rules, experimentation
  // or tracking purposes.
  // Eg. country_code, service_type, service_area_id 
  repeated Variable prediction_context = 3;

  // Request metadata
  RequestMetadata metadata = 10;
}

message RequestMetadata {

  // Unique identifier for each request. Optional.
  // Prediction ID will generated by the platform. The user is expected
  // include the prediction ID (along with row ID) when calling
  // the observations API so that predictions and observations can be joined.
  // Prediction ID is needed because row ID may not be globally unique
  // across requests (only locally unique within each request).
  // If there are experiments with alternative models, the mapping
  // from prediciton ID to treatment ID will be logged by the platform
  string prediction_id = 1;

  // Timestamp of the request
  google.protobuf.Timestamp request_timestamp = 2;
}

message PredictValuesResponse {
  // Prediction results corresponding to the
  // prediction rows provided in the request. 
  // NOTE: the ordering of prediction_result_rows might differ with prediction_table in the request but the number of row must match with the prediction_table
  Table prediction_result_table = 1;

  // Target name as defined in the request metadata
  string target_name = 2;

  // Extensible field to cover unforeseen requirements
  repeated Variable prediction_context = 3;

  // Response metadata
  ResponseMetadata metadata = 10;
}

message ResponseMetadata {
  // Prediction ID generated by the platform. 
  // The user is expected include the prediction ID (along with row ID) when calling
  // the observations API so that predictions and observations can be joined.
  // Prediction ID is needed because row ID may not be globally unique
  // across requests (only locally unique within each request).
  // If there are experiments with alternative models, the mapping
  // from prediciton ID to treatment ID will be logged by the platform
  string prediction_id = 1;

  // List of model that produces the prediction 
  // This field is repeated to cater for use case such as ensembling several model production results
  repeated ModelMetadata models = 2;

  // Optional experimentation metadata
  string experiment_id = 3;
  string treatment_id = 4;
}

message ModelMetadata {
  // Model name that produce prediction
  string name = 1;
  // Model version that produce prediction
  string version = 2;
} 

// Transformer input contains additional information that can be used to enrich prediction_table using standard transformer.
// All tables and variables within transformer input will be imported to the standard transformer runtime automatically.
message TransformerInput {
   // List of tables
   // All tables must have unique name.
   // Each table doesn't need to have same number of row.
   repeated Table tables = 1;  
   // List of variables
   repeated Variable variables = 2;
}
